#!/bin/bash

# ðŸ”± ARCH FORTRESS - PART 2: ARSENAL DEPLOYMENT ðŸ”±

# Fixed Python compatibility and enhanced error handling

set -euo pipefail

# Colors for output

RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
NC="\033[0m"

# Configuration

USERNAME="mastermind"
HOSTNAME="fortress"
FIREFOX_PROFILE="fortress-secure"
DNS_NETWORK="dns-isolated"
FIREFOX_NETWORK="firefox-isolated"

# Logging functions

log() {
echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
echo -e "${RED}[ERROR]${NC} $1" >&2
exit 1
}

warning() {
echo -e "${YELLOW}[WARNING]${NC} $1"
}

info() {
echo -e "${BLUE}[INFO]${NC} $1"
}

# Verify Part 1 installation

verify_part1() {
log "ðŸ” Verifying Part 1 installationâ€¦"


# Check if we're running as user
if [[ $EUID -eq 0 ]]; then
    error "Do not run Part 2 as root. Run as user $USERNAME"
fi

# Check AppArmor
if ! sudo systemctl is-active apparmor >/dev/null 2>&1; then
    error "AppArmor not running. Check Part 1 installation."
fi

# Check Podman
if ! command -v podman >/dev/null 2>&1; then
    error "Podman not found. Check Part 1 installation."
fi

log "âœ… Part 1 verification complete"


}

# Install GPU drivers and CUDA

setup_gpu_cuda() {
log "ðŸŽ® Setting up NVIDIA GPU and CUDAâ€¦"


# Install NVIDIA drivers
sudo pacman -S --noconfirm \
    nvidia-dkms \
    nvidia-utils \
    nvidia-settings \
    lib32-nvidia-utils \
    cuda \
    cudnn \
    opencl-nvidia

# Configure NVIDIA persistence
sudo systemctl enable nvidia-persistenced

# Add user to video group
sudo usermod -a -G video $USERNAME

# Configure NVIDIA settings
sudo tee /etc/modprobe.d/nvidia.conf > /dev/null << 'EOF'


# Enable NVIDIA KMS

options nvidia-drm modeset=1

# Security hardening

options nvidia NVreg_RestrictProfilingToAdminUsers=1
EOF


# Update initramfs
sudo mkinitcpio -P

log "âœ… NVIDIA GPU and CUDA setup complete"


}

# Install minimal KDE Plasma

setup_minimal_kde() {
log "ðŸ–¥ï¸ Installing minimal KDE Plasmaâ€¦"


# Install minimal KDE
sudo pacman -S --noconfirm \
    xorg-server \
    plasma-desktop \
    plasma-workspace \
    kscreen \
    plasma-systemmonitor \
    konsole \
    dolphin \
    kate \
    sddm \
    sddm-kcm \
    ark \
    spectacle \
    breeze \
    plasma-browser-integration

# Enable SDDM
sudo systemctl enable sddm

# Configure SDDM for security
sudo tee /etc/sddm.conf > /dev/null << 'EOF'


[General]
HaltCommand=/usr/bin/systemctl poweroff
RebootCommand=/usr/bin/systemctl reboot
Numlock=on

[Theme]
Current=breeze

[Users]
MaximumUid=60513
MinimumUid=1000
HideUsers=
HideShells=/bin/false,/usr/bin/nologin

[X11]
MinimumVT=1
ServerArguments=-nolisten tcp -dpi 96
EOF


# Disable unnecessary KDE services
sudo systemctl mask \
    plasma-baloorunner \
    baloo-file \
    baloo-file-extractor

log "âœ… Minimal KDE Plasma installed"


}

# Setup Firefox with AppArmor isolation

setup_firefox_isolation() {
log "ðŸ¦Š Setting up Firefox with AppArmor isolationâ€¦"

# Explicitly install apparmor to ensure all abstractions are present
sudo pacman -S --noconfirm apparmor

# Install Firefox
sudo pacman -S --noconfirm firefox

# Create Firefox AppArmor profile
sudo tee /etc/apparmor.d/firefox-fortress > /dev/null << 'EOF'


# Firefox security profile for Fortress

#include <tunables/global>

profile firefox-fortress /usr/lib/firefox/firefox flags=(attach_disconnected) {
#include <abstractions/base>
#include <abstractions/audio>
#include <abstractions/dbus-session-strict>
#include <abstractions/dbus-accessibility-strict>
#include <abstractions/fonts>
#include <abstractions/freedesktop.org>
#include <abstractions/mesa>
#include <abstractions/nameservice>
#include <abstractions/openssl>
#include <abstractions/p11-kit>
#include <abstractions/ssl_certs>
#include <abstractions/user-tmp>
#include <abstractions/wayland>
#include <abstractions/X>

owner @{HOME}/.config/dconf/user r,
owner @{HOME}/.cache/fontconfig/ rw,
owner @{HOME}/.cache/fontconfig/** rw,

# Firefox binary and libraries

/usr/lib/firefox/firefox rix,
/usr/lib/firefox/** r,
/usr/lib/firefox/plugin-container ix,
/usr/lib/firefox/firefox-bin rix,

# Firefox profile directory (restricted)

owner @{HOME}/.mozilla/firefox/fortress-secure/** rw,
owner @{HOME}/.mozilla/firefox/profiles.ini r,
owner @{HOME}/.mozilla/firefox/installs.ini r,

# Downloads directory (restricted)

owner @{HOME}/Downloads/firefox/** rw,
owner @{HOME}/Downloads/firefox/ rw,

# System directories (read-only)

/usr/share/firefox/** r,
/usr/share/mime/** r,
/usr/share/applications/** r,
/etc/firefox/** r,
/etc/mime.types r,

# Networking

network inet dgram,
network inet stream,
network inet6 dgram,
network inet6 stream,
network netlink raw,

# Process control

/usr/bin/lsb_release Px,
/usr/bin/basename ix,
/usr/bin/dirname ix,

# Denied access

deny @{HOME}/.ssh/** rw,
deny @{HOME}/.gnupg/** rw,
deny @{HOME}/Documents/** rw,
deny @{HOME}/.config/** rw,
deny @{HOME}/.local/share/** rw,
deny /etc/shadow r,
deny /etc/passwd r,
deny /proc/*/environ r,
deny /sys/devices/virtual/dmi/** r,
deny capability sys_admin,
deny capability sys_ptrace,
deny capability sys_module,

# Temporary files

owner /tmp/firefox-fortress/** rw,
owner /var/tmp/firefox-fortress/** rw,
}
EOF


# Create secure Firefox profile and necessary directories
log "Manually creating secure Firefox profile..."
mkdir -p "$HOME/.mozilla/firefox/fortress-secure"

# Create profiles.ini so Firefox knows about the new profile on first launch
tee "$HOME/.mozilla/firefox/profiles.ini" > /dev/null << 'EOF'
[Install4F96D09476724483]
Default=fortress-secure
Locked=1

[Profile1]
Name=fortress-secure
IsRelative=1
Path=fortress-secure
Default=1

[General]
StartWithLastProfile=1
Version=2
EOF

# Create Firefox user.js for security
tee $HOME/.mozilla/firefox/fortress-secure/user.js > /dev/null << 'EOF'


// Firefox Security Configuration for Fortress
// Disable telemetry and data collection
user_pref("datareporting.policy.dataSubmissionEnabled", false);
user_pref("datareporting.healthreport.uploadEnabled", false);
user_pref("toolkit.telemetry.unified", false);
user_pref("toolkit.telemetry.enabled", false);
user_pref("browser.newtabpage.activity-stream.feeds.telemetry", false);
user_pref("browser.newtabpage.activity-stream.telemetry", false);
user_pref("browser.ping-centre.telemetry", false);

// Disable studies and experiments
user_pref("app.shield.optoutstudies.enabled", false);
user_pref("app.normandy.enabled", false);
user_pref("app.normandy.api_url", "");

// Enhanced security settings
user_pref("security.tls.version.min", 3);
user_pref("security.ssl.require_safe_negotiation", true);
user_pref("security.ssl.treat_unsafe_negotiation_as_broken", true);
user_pref("security.tls.insecure_fallback_hosts", "");
user_pref("security.cert_pinning.enforcement_level", 2);

// Privacy enhancements
user_pref("privacy.trackingprotection.enabled", true);
user_pref("privacy.trackingprotection.socialtracking.enabled", true);
user_pref("privacy.resistFingerprinting", true);
user_pref("privacy.firstparty.isolate", true);
user_pref("network.cookie.cookieBehavior", 1);
user_pref("network.http.referer.XOriginPolicy", 1);

// Disable dangerous features
user_pref("javascript.options.wasm", false);
user_pref("dom.webnotifications.enabled", false);
user_pref("geo.enabled", false);
user_pref("media.navigator.enabled", false);
user_pref("webgl.disabled", true);

// Network isolation
user_pref("network.proxy.type", 0);
user_pref("network.dns.disablePrefetch", true);
user_pref("network.prefetch-next", false);
user_pref("network.predictor.enabled", false);
EOF


# Load Firefox AppArmor profile
sudo apparmor_parser -r /etc/apparmor.d/firefox-fortress

# Create Firefox launcher script
mkdir -p $HOME/.local/bin
tee $HOME/.local/bin/firefox-fortress > /dev/null << 'EOF'


#!/bin/bash

# Launcher to enforce AppArmor profile on host Firefox

exec aa-exec -p firefox-fortress /usr/lib/firefox/firefox "$@"
EOF


chmod +x $HOME/.local/bin/firefox-fortress

log "âœ… Firefox isolation configured"


}

# Setup development environment with proper Python version management

# Setup development environment with proper Python version management

setup_development() {
log â€œðŸ’» Setting up development environmentâ€¦â€
export PATH=â€$HOME/.local/bin:$PATHâ€


# Install development tools and optimized Python stack
sudo pacman -S --noconfirm \
    base-devel \
    python-numpy \
    python-scipy \
    python-pandas \
    python-matplotlib \
    python-scikit-learn \
    python-pytorch-cuda \
    python-tensorflow-cuda \
    jupyter-notebook \
    python-pip \
    python-virtualenv \
    nodejs \
    npm \
    go \
    podman-compose \
    github-cli \
    git \
    vim

# Install Rust
sudo pacman -S --needed --noconfirm rustup
rustup default stable

# Install paru (AUR helper) securely
if ! command -v paru >/dev/null 2>&1; then
    log "Installing paru AUR helper..."
    cd /tmp
    git clone https://aur.archlinux.org/paru.git
    cd paru
    makepkg -si --noconfirm
    cd ~
    rm -rf /tmp/paru
fi

# Install VSCodium after paru is available
paru -S --noconfirm vscodium-bin

# Create secure development directories
mkdir -p $HOME/{Projects,AI,Scripts}
chmod 750 $HOME/{Projects,AI,Scripts}

# Configure Git
git config --global init.defaultBranch main
git config --global pull.rebase true
git config --global core.editor vim

# Create lightweight development environment using system packages
log "Creating optimized Python environment..."
python -m venv --system-site-packages $HOME/.local/share/dev-env
source $HOME/.local/share/dev-env/bin/activate

# Install only additional development tools
pip install --no-deps black flake8 pylint pytest mypy semgrep bandit

# Create activation script
tee $HOME/.local/bin/dev-activate > /dev/null << 'EOF'


#!/bin/bash
source $HOME/.local/share/dev-env/bin/activate
echo â€œðŸ Development environment activated (System Python + extras)â€
echo â€œPython: $(python â€“version)â€
echo â€œPyTorch: $(python -c â€˜import torch; print(torch.**version**)â€™ 2>/dev/null || echo â€˜Not availableâ€™)â€
echo â€œTensorFlow: $(python -c â€˜import tensorflow; print(tensorflow.**version**)â€™ 2>/dev/null || echo â€˜Not availableâ€™)â€
EOF


chmod +x $HOME/.local/bin/dev-activate

deactivate

log "âœ… Development environment configured with optimized Python stack"
info "Use 'dev-activate' to activate development environment"


}

# Setup Obsidian with Syncthing

setup_obsidian_syncthing() {
log "ðŸ“ Setting up Obsidian with Syncthingâ€¦"


# Install Obsidian and Syncthing
paru -S --noconfirm obsidian syncthing

# Create Obsidian vault directory
mkdir -p $HOME/Documents/ObsidianVault

# Create Obsidian AppArmor profile
sudo tee /etc/apparmor.d/obsidian > /dev/null << 'EOF'


# Obsidian security profile

#include <tunables/global>

profile obsidian /opt/Obsidian/obsidian flags=(attach_disconnected) {
#include <abstractions/base>
#include <abstractions/fonts>
#include <abstractions/freedesktop.org>
#include <abstractions/user-tmp>
#include <abstractions/wayland>
#include <abstractions/X>

owner @{HOME}/.config/dconf/user r,
owner @{HOME}/.cache/fontconfig/ rw,
owner @{HOME}/.cache/fontconfig/** rw,

# Obsidian binary and libraries

/opt/Obsidian/obsidian rix,
/opt/Obsidian/** r,

# Vault access (restricted to vault directory)

owner @{HOME}/Documents/ObsidianVault/** rw,
owner @{HOME}/.config/obsidian/** rw,

# System directories (read-only)

/usr/share/applications/** r,
/usr/share/mime/** r,

# Networking (required for sync and plugins)

network inet dgram,
network inet stream,
network inet6 dgram,
network inet6 stream,

# Deny sensitive directories

deny @{HOME}/.ssh/** rw,
deny @{HOME}/.gnupg/** rw,
deny capability sys_admin,
deny capability sys_ptrace,
deny capability sys_module,
}
EOF


# Load Obsidian AppArmor profile
sudo apparmor_parser -r /etc/apparmor.d/obsidian

# Configure Syncthing
systemctl --user enable syncthing.service
systemctl --user start syncthing.service

# Create Syncthing AppArmor profile
sudo tee /etc/apparmor.d/syncthing > /dev/null << 'EOF'


# Syncthing security profile

#include <tunables/global>

profile syncthing /usr/bin/syncthing flags=(attach_disconnected) {
#include <abstractions/base>
#include <abstractions/nameservice>
#include <abstractions/openssl>

# Syncthing binary

/usr/bin/syncthing rix,

# Configuration and data

owner @{HOME}/.config/syncthing/** rw,
owner @{HOME}/.local/share/syncthing/** rw,
owner @{HOME}/Documents/ObsidianVault/** rw,

# Network access for sync

network inet dgram,
network inet stream,
network inet6 dgram,
network inet6 stream,

# Deny sensitive directories

deny @{HOME}/.ssh/** rw,
deny @{HOME}/.gnupg/** rw,
deny capability sys_admin,
deny capability sys_ptrace,
deny capability sys_module,
}
EOF


# Load Syncthing AppArmor profile
sudo apparmor_parser -r /etc/apparmor.d/syncthing

log "âœ… Obsidian and Syncthing configured"
info "Access Syncthing at: http://127.0.0.1:8384"


}

#
# ðŸ”± FORTRESS DNS: Production Hardened & Sovereign Setup (Ultimate Version) ðŸ”±
#
# This function establishes a two-stage, privacy-enhancing DNS resolution system.
# Stage 1: Unbound acts as a local, validating, recursive, and caching DNS resolver.
#          It is tuned for maximum performance and security on the target hardware.
# Stage 2: DNSCrypt-Proxy acts as a stateless, anonymizing transport proxy. It takes
#          plaintext DNS queries from Unbound and forwards them over Oblivious
#          DNS-over-HTTPS (ODoH) via a mandatory, geographically diverse relay network.
#
# This architecture ensures:
#   - High performance via local caching (Unbound).
#   - Cryptographic validation of DNS integrity (DNSSEC via Unbound).
#   - Encryption of DNS queries from this machine to the resolver (DoH).
#   - Anonymization by decoupling the query source IP from the query content (ODoH Relays).
#
setup_fortress_dns() {
    log "ðŸ›¡ï¸ FORTRESS DNS: Deploying Production Hardened & Sovereign Setup..."

    # --- DYNAMIC PERFORMANCE TUNING ---
    # Dynamically determine system resources for optimal Unbound performance.
    local CPU_THREADS
    CPU_THREADS=$(nproc)
    # Cache slabs should be a power of 2 near the thread count to reduce lock contention.
    # For simplicity and effectiveness, we will set it equal to the thread count,
    # as this is a common and robust practice.
    local CACHE_SLABS=$CPU_THREADS
    info "System detected with $CPU_THREADS CPU threads. Tuning Unbound accordingly."

    # --- INSTALLATION ---
    log "Installing Unbound and DNSCrypt-Proxy..."
    sudo pacman -S --needed --noconfirm unbound dnscrypt-proxy

    # Verify that the dnscrypt-proxy package correctly created its dedicated user.
    if! id "dnscrypt-proxy" &>/dev/null; then
        error "The 'dnscrypt-proxy' user was not created. Package installation may have failed."
        error "Check pacman logs (/var/log/pacman.log) and network connectivity."
        return 1
    fi

    # --- CONFIGURATION: DNSCrypt-Proxy (The Armored Transport) ---
    log "Configuring dnscrypt-proxy for mandatory Oblivious DoH transport..."
    sudo tee /etc/dnscrypt-proxy/dnscrypt-proxy.toml > /dev/null << 'EOF'
# This instance is ONLY for Unbound's recursive lookups.
# It is a stateless transport layer. Caching is disabled.
server_names = ['odoh-ibksturm', 'odoh-cloudflare', 'odoh-quad9-de', 'odoh-securedns-eu']

# --- MANDATORY ODoH ROUTING ---
# Force queries through anonymizing relays. If a relay fails, the query fails. No fallback.
# This ensures the client IP is always decoupled from the DNS resolver.
routes = [
    { server_name = 'odoh-ibksturm',   via = ['odohrelay-ams', 'odohrelay-se'] },
    { server_name = 'odoh-cloudflare', via = ['odohrelay-se', 'odohrelay-ams'] },
    { server_name = 'odoh-quad9-de',   via = ['odohrelay-ams', 'odohrelay-ch'] },
    { server_name = 'odoh-securedns-eu', via = ['odohrelay-ch', 'odohrelay-se'] }
]

# Listen on a high local port for Unbound to connect to.
# This is for local inter-process communication only.
listen_addresses = ['127.0.0.1:5353', '[::1]:5353']

# Caching is DISABLED. Unbound is the sole cache authority in this stack.
# Enabling cache here would lead to stale data and unpredictable TTLs.
cache = false

# Security First: Require DNSSEC validation, no logs, and no filtering from the upstream resolver.
# Unbound handles DNSSEC validation locally, and we handle filtering via blocklists.
require_dnssec = true
require_nolog = true
require_nofilter = true

# Use modern, privacy-preserving protocols ONLY.
doh_servers = true
odoh_servers = true
dnscrypt_servers = false
dot_servers = false

# Performance and reliability tuning.
timeout = 5000
keepalive = 30
lb_strategy = 'p2'
lb_estimator = true

# Privacy settings.
block_unqualified = true
block_undelegated = true

# Bootstrap with trusted public resolvers. This is only for the initial startup of dnscrypt-proxy.
bootstrap_resolvers = ['9.9.9.9:53', '1.1.1.1:53']
ignore_system_dns = true

# Suppress operational logs for privacy and to reduce disk I/O.
log_level = 0
EOF

    # --- CONFIGURATION: Unbound (The Sovereign Resolver) ---
    log "Configuring Unbound as a hardened, caching, recursive resolver..."
    # Note: The 'heredoc' uses 'EOF' to prevent shell expansion of variables like $CPU_THREADS.
    # We will use sed to substitute the dynamic values after writing the template.
    sudo tee /etc/unbound/unbound.conf > /dev/null << 'EOF'
server:
    # Service configuration
    interface: 127.0.0.1@53
    interface: ::1@53
    do-ip4: yes
    do-ip6: yes
    do-udp: yes
    do-tcp: yes
    access-control: 127.0.0.0/8 allow
    access-control: ::1/128 allow
    # Enable socket reuse for high performance on multi-core Linux systems.
    so-reuseport: yes

    # --- DYNAMIC PERFORMANCE TUNING ---
    # These values will be replaced by the script.
    num-threads: __CPU_THREADS__
    msg-cache-slabs: __CACHE_SLABS__
    rrset-cache-slabs: __CACHE_SLABS__
    infra-cache-slabs: __CACHE_SLABS__
    key-cache-slabs: __CACHE_SLABS__

    # --- STATIC PERFORMANCE & CACHE TUNING ---
    # Allocate generous cache sizes. Total memory usage will be ~2-2.5x this amount.
    msg-cache-size: 128m
    rrset-cache-size: 256m
    # Handle high query loads without dropping packets. Requires libevent (default on Arch).
    outgoing-range: 8192
    num-queries-per-thread: 4096
    # Increase kernel socket buffer to avoid drops during traffic spikes.
    so-rcvbuf: 4m
    so-sndbuf: 4m

    # Caching Behavior - Balanced for performance and freshness.
    cache-min-ttl: 0        # Respect the record's TTL.
    cache-max-ttl: 86400    # Cache for a maximum of 1 day.
    serve-expired: yes      # Serve stale data if resolvers are unreachable (improves resilience).
    serve-expired-ttl: 3600 # But only for up to an hour.
    prefetch: yes           # Proactively fetch popular items before they expire.
    prefetch-key: yes       # Proactively fetch DNSKEYs.

    # --- DNSSEC: Authoritative Local Validation ---
    auto-trust-anchor-file: "/var/lib/unbound/root.key"
    val-clean-additional: yes
    harden-dnssec-stripped: yes

    # --- SECURITY & PRIVACY HARDENING ---
    hide-identity: yes
    hide-version: yes
    harden-glue: yes
    harden-below-nxdomain: yes
    # CRITICAL: Harden referral path to validate NS records in the chain of trust.
    # This prevents sophisticated redirection attacks. Aligns with Fortress philosophy.
    harden-referral-path: yes
    qname-minimisation: yes
    qname-minimisation-strict: yes
    aggressive-nsec: yes
    use-caps-for-id: yes
    unwanted-reply-threshold: 10000000

    # Anti-DNS Rebinding Protection.
    private-address: 10.0.0.0/8
    private-address: 172.16.0.0/12
    private-address: 192.168.0.0/16
    private-address: 169.254.0.0/16
    private-address: fd00::/8
    private-address: fe80::/10

    # --- FORWARDING CONFIGURATION ---
    # This is the core logic: forward ALL queries to our local, plaintext dnscrypt-proxy listener.
    # DO NOT use 'ssl-upstream: yes' here. That would cause a fatal protocol mismatch.
    do-not-query-localhost: no
    forward-zone:
        name: "."
        forward-addr: 127.0.0.1@5353
        forward-addr: ::1@5353

    # Include user-defined block and white lists.
    include: "/etc/unbound/user_lists.conf"
EOF

    # Substitute the dynamic performance values into the Unbound config file.
    sudo sed -i "s/__CPU_THREADS__/$CPU_THREADS/g" /etc/unbound/unbound.conf
    sudo sed -i "s/__CACHE_SLABS__/$CACHE_SLABS/g" /etc/unbound/unbound.conf

    # --- PREPARATION: Clear the ground ---
    log "Disabling and masking conflicting DNS services..."
    sudo systemctl disable --now systemd-resolved dnsmasq 2>/dev/null |

| true
    sudo systemctl mask systemd-resolved.service

    # --- BLOCKLISTING ---
    log "Installing robust, self-updating blocklist mechanism..."
    sudo tee /usr/local/bin/update-dns-blocklist > /dev/null << 'EOF'
#!/bin/bash
set -euo pipefail

BLOCKLIST_PATH="/etc/unbound/blocklist.conf"
TEMP_FILE=$(mktemp)
WHITELIST_PATH="/etc/unbound/whitelist.conf"
# Whitelist essential domains to prevent breakage. Add your own if needed.
WHITELIST_DOMAINS=(
    "*.mullvad.net" "*.quad9.net" "*.archlinux.org"
    "*.github.com" "githubusercontent.com" "*.fedoraproject.org"
)
# User-Agent to be a good network citizen.
USER_AGENT="ArchFortress-Blocklist-Updater/1.0"

# Add more trusted blocklist sources here.
SOURCES=(
    "https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts"
    "https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&showintro=0&mimetype=plaintext"
    "https://raw.githubusercontent.com/AdguardTeam/AdguardFilters/master/BaseFilter/sections/adservers.txt"
    "https://osint.digitalside.it/Threat-Intel/lists/latestdomains.txt"
)

# Download and process sources into Unbound's local-zone format.
{
    for url in "${SOURCES[@]}"; do
        timeout 30 curl -sS -A "$USER_AGENT" --tlsv1.2 --tls-max 1.3 "$url" 2>/dev/null |

| continue
    done
} | awk '
    # For hosts format (e.g., 0.0.0.0 domain.com)
    /^(0\.0\.0\.0|127\.0\.0\.1)[[:space:]]+[^[:space:]#]/ && $2!~ /^(localhost|localhost\.localdomain)$/ {
        gsub(/\r/, ""); domains[$2]++
    }
    # For AdGuard format (e.g., ||domain.com^)
    /^\|\|[a-zA-Z0-9.\-]+\^/ {
        gsub(/[|\^]/, ""); gsub(/\r/, ""); domains[$0]++
    }
    # For simple domain list format
    /^[a-zA-Z0-9.-]+$/ {
        gsub(/\r/, ""); domains[$0]++
    }
    END {
        for (domain in domains) {
            print "local-zone: \"" domain "\" refuse"
        }
    }
' | sort -u > "$TEMP_FILE"

# Generate the whitelist configuration.
{
    for domain in "${WHITELIST_DOMAINS[@]}"; do
        echo "local-zone: \"${domain}.\" transparent"
    done
} | sudo tee "$WHITELIST_PATH" > /dev/null

# Atomically update the blocklist if the new one is valid and contains a sane number of entries.
if]; then
    sudo mv "$TEMP_FILE" "$BLOCKLIST_PATH"
    if systemctl is-active --quiet unbound; then
        sudo unbound-control reload_keep_cache >/dev/null
        logger "FORTRESS DNS: Blocklist updated successfully with $(wc -l < "$BLOCKLIST_PATH") domains."
    fi
else
    logger "FORTRESS DNS: Blocklist update failed or list was too small. Using existing list."
    rm -f "$TEMP_FILE"
fi
EOF
    sudo chmod +x /usr/local/bin/update-dns-blocklist

    # Create the include file for Unbound and run the update script for the first time.
    sudo tee /etc/unbound/user_lists.conf > /dev/null << 'EOF'
# Include user-defined block and white lists
include: "/etc/unbound/whitelist.conf"
include: "/etc/unbound/blocklist.conf"
EOF
    sudo /usr/local/bin/update-dns-blocklist

    # --- AUTOMATION: Systemd Timers ---
    log "Setting up systemd timers for automatic blocklist updates..."
    sudo tee /etc/systemd/system/dns-blocklist-update.service > /dev/null << 'EOF'
[Unit]
Description=Update Unbound DNS blocklist
After=network-online.target
Wants=network-online.target

Type=oneshot
ExecStart=/usr/local/bin/update-dns-blocklist
EOF
    sudo tee /etc/systemd/system/dns-blocklist-update.timer > /dev/null << 'EOF'
[Unit]
Description=Daily update for Unbound DNS blocklist

OnCalendar=daily
RandomizedDelaySec=6h
Persistent=true
[Install]
WantedBy=timers.target
EOF

    # --- NETWORK INTEGRATION & LEAK PREVENTION ---
    log "Hardening network configuration against DNS leaks..."
    # Tell NetworkManager to use this system's resolver exclusively.
    sudo mkdir -p /etc/NetworkManager/conf.d
    echo -e "[main]\ndns=none\nsystemd-resolved=false\n[connection]\nipv6.ip6-privacy=2" | sudo tee /etc/NetworkManager/conf.d/99-dns-fortress.conf > /dev/null

    # Apply surgical firewall rule to allow ONLY the dnscrypt-proxy user to make outbound connections.
    if command -v firewall-cmd &>/dev/null && sudo systemctl is-active --quiet firewalld; then
        log "Applying firewalld rule to prevent DNS leaks..."
        sudo firewall-cmd --permanent --zone=trusted --remove-source=uid:dnscrypt-proxy >/dev/null 2>&1 # Clean up old rule if present
        sudo firewall-cmd --permanent --zone=trusted --add-source=uid:dnscrypt-proxy
        sudo firewall-cmd --reload
    fi

    # Make resolv.conf mutable before writing, then lock it down.
    [[ -f /etc/resolv.conf ]] && sudo chattr -i /etc/resolv.conf 2>/dev/null |

| true
    sudo tee /etc/resolv.conf > /dev/null << 'EOF'
# This system uses a local, hardened, caching, and anonymizing DNS resolver.
# Do not edit this file manually. It is managed by the Arch Fortress scripts.
nameserver 127.0.0.1
nameserver ::1
options edns0 trust-ad timeout:1 rotate
EOF
    sudo chattr +i /etc/resolv.conf

    # --- ROBUST STARTUP ORCHESTRATION ---
    # Create a systemd override to guarantee Unbound starts AFTER dnscrypt-proxy
    # and is stopped if dnscrypt-proxy fails. This prevents DNS black-holing.
    log "Creating systemd override for robust service startup..."
    sudo mkdir -p /etc/systemd/system/unbound.service.d
    sudo tee /etc/systemd/system/unbound.service.d/override.conf > /dev/null <<'EOF'
[Unit]
# Ensure dnscrypt-proxy is running before Unbound starts.
After=dnscrypt-proxy.service
# If dnscrypt-proxy stops or crashes, stop Unbound too.
BindsTo=dnscrypt-proxy.service
EOF

    # --- ACTIVATION ---
    log "Activating and enabling services..."
    sudo systemctl daemon-reload
    sudo systemctl enable --now dns-blocklist-update.timer
    # Start the proxy first, then the resolver. The override ensures this order.
    sudo systemctl enable --now dnscrypt-proxy.service
    sudo systemctl enable --now unbound.service
    # Restart NetworkManager to apply the new DNS configuration.
    sudo systemctl restart NetworkManager.service

    # --- VERIFICATION ---
    log "Verifying the fortress..."
    sleep 3 # Allow services a moment to stabilize before testing.

    local VERIFIED=true
    if! timeout 5 dig @127.0.0.1 +dnssec archlinux.org >/dev/null; then
        error "DNS resolution test FAILED. Could not resolve archlinux.org."
        VERIFIED=false
    fi
    if! timeout 5 dig @127.0.0.1 sigfail.verteiltesysteme.net 2>&1 | grep -q "status: SERVFAIL"; then
        error "DNSSEC validation test FAILED. Did not get SERVFAIL for a known bad signature."
        VERIFIED=false
    fi
    if! unbound-control status 2>/dev/null | grep -q "is running"; then
        error "Unbound service is not running or unbound-control failed."
        VERIFIED=false
    fi

    if]; then
        log "âœ… DNS resolution operating normally."
        log "âœ… DNSSEC validation CONFIRMED (Correctly returned SERVFAIL for a bad signature)."
        log "âœ… Blocklist contains $(wc -l < /etc/unbound/blocklist.conf | awk '{print $1}') domains."
        log "ðŸ›¡ï¸ FORTRESS DNS is online and protecting your network."
    else
        error "DNS verification FAILED. Please check service status with:"
        error "--> sudo systemctl status unbound.service dnscrypt-proxy.service"
        error "--> sudo journalctl -u unbound -u dnscrypt-proxy -e"
        error "--> sudo unbound-control status"
        return 1
    fi
}

# Setup Snapper for snapshots

setup_snapper() {
log "ðŸ“¸ Setting up Snapper for snapshotsâ€¦"


# Install Snapper
sudo pacman -S --noconfirm snapper snap-pac

# Create Snapper configuration for root
sudo snapper -c root create-config /

# Create Snapper configuration for home
sudo snapper -c home create-config /home

# Configure Snapper settings for both root and home
for config in root home; do
    log "ðŸ”§ Configuring Snapper for '$config'..."
    sudo snapper -c "$config" set-config \
        "TIMELINE_CREATE=yes" \
        "TIMELINE_LIMIT_HOURLY=5" \
        "TIMELINE_LIMIT_DAILY=7" \
        "TIMELINE_LIMIT_WEEKLY=0" \
        "TIMELINE_LIMIT_MONTHLY=2" \
        "NUMBER_CLEANUP=yes" \
        "NUMBER_LIMIT=25" \
        "NUMBER_LIMIT_IMPORTANT=10"
done

# Enable Snapper timers
sudo systemctl enable --now snapper-timeline.timer
sudo systemctl enable --now snapper-cleanup.timer

# Create initial snapshot
sudo snapper -c root create --description "Initial fortress snapshot"

log "âœ… Snapper configured"


}

# Setup system monitoring

setup_monitoring() {
log "ðŸ“Š Setting up system monitoringâ€¦"


# Install monitoring tools
sudo pacman -S --noconfirm \
    htop \
    iotop \
    nethogs \
    fail2ban \
    logwatch \
    rkhunter

# Configure fail2ban
sudo tee /etc/fail2ban/jail.local > /dev/null << 'EOF'


[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 3
backend = systemd
usedns = warn
logencoding = auto
enabled = false
filter = %(**name**)s
destemail = root@localhost
sender = root@localhost
action = %(action_)s

[sshd]
enabled = true
port = ssh
logpath = %(sshd_log)s
backend = %(sshd_backend)s
banaction = firewallcmd-multiport
EOF


# Enable fail2ban
sudo systemctl enable --now fail2ban

# Configure rkhunter
sudo rkhunter --update
sudo rkhunter --propupd

# Create monitoring script
tee $HOME/.local/bin/fortress-status > /dev/null << 'EOF'


#!/bin/bash

# Fortress System Status

echo "ðŸ”± FORTRESS STATUS REPORT ðŸ”±"
echo "=================================="
echo

echo "ðŸ“Š System Resources:"
echo "CPU: $(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage "%"}')"
echo "Memory: $(free | grep Mem | awk '{printf("%.1f%%\n", $3/$2 * 100.0)}')"
echo "Disk: $(df -h / | awk 'NR==2{print $5}')"
echo

echo "ðŸ”’ Security Status:"
echo "AppArmor: $(sudo apparmor_status | grep -c 'profiles are loaded')"
echo "Firewall: $(sudo firewall-cmd --state 2>/dev/null || echo 'inactive')"
echo "Fail2ban: $(sudo fail2ban-client status | grep -c 'jail(s)')"
echo

echo "ðŸ³ Container Status:"
podman ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
echo

echo "ðŸ“¸ Recent Snapshots:"
sudo snapper -c root list -t single | tail -5
echo

echo "ðŸ Python Environments:"
echo "System Python: $(python --version 2>/dev/null || echo 'Not available')"
if [[ -f "$HOME/.local/share/dev-env/bin/python" ]]; then
echo "Dev Environment: $($HOME/.local/share/dev-env/bin/python --version)"
fi
EOF


chmod +x $HOME/.local/bin/fortress-status

log "âœ… System monitoring configured"


}

# Setup MAC address randomization

setup_mac_randomization() {
log "ðŸ”’ Configuring MAC address randomizationâ€¦"


# Create a NetworkManager configuration file for MAC randomization
sudo tee /etc/NetworkManager/conf.d/00-macrandomize.conf > /dev/null << 'EOF'


# Enable MAC address randomization for privacy

[device]

# Randomize MAC address during Wi-Fi scans

wifi.scan-rand-mac-address=yes

[connection]

# Use a stable, per-network random MAC address for Wi-Fi

wifi.cloned-mac-address=stable

# Use a stable, random MAC address for Ethernet

ethernet.cloned-mac-address=stable

# Generate a stable ID for connections

connection.stable-id=${CONNECTION}/${BOOT}
EOF


log "âœ… MAC address randomization enabled for new connections."
info "Existing connections may need to be modified with 'nmcli'."


}

# Apply final security hardening

apply_final_hardening() {
log "ðŸ” Applying final security hardeningâ€¦"


# Create security aliases
tee -a $HOME/.bashrc > /dev/null << 'EOF'


# Fortress Security Aliases

alias ls='ls --color=auto'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias grep='grep --color=auto'
alias firefox='firefox-fortress'
alias status='fortress-status'
alias ss='sudo snapper -c root create --description'
alias sr='sudo snapper -c root'

# Security-focused PATH

export PATH="$HOME/.local/bin:$PATH"

# Development environment

alias dev='dev-activate'
alias dev-env='source $HOME/.local/share/dev-env/bin/activate'

EOF


# Set proper permissions
chmod 700 $HOME/.ssh 2>/dev/null || true
chmod 600 $HOME/.ssh/* 2>/dev/null || true
chmod 700 $HOME/.gnupg 2>/dev/null || true
chmod 600 $HOME/.gnupg/* 2>/dev/null || true


}

# Main installation function

main() {
log "ðŸ”± Starting Arch Fortress Installation - Part 2 ðŸ”±"


# Verify Part 1 installation
verify_part1

# GPU and KDE setup
#setup_gpu_cuda
#setup_minimal_kde

# Application isolation
#setup_firefox_isolation
#setup_obsidian_syncthing

# Development environment (with fixed Python compatibility)
#setup_development

# A function to log messages
log() {
    echo -e "[\e[32m+\e[0m] $1"
}

# A function to log errors
error() {
    echo -e "[\e[31m!\e[0m] $1" >&2
}
# Execute dns function
setup_fortress_dns

# System maintenance
setup_snapper
setup_monitoring

# Final hardening
setup_mac_randomization
apply_final_hardening

log "âœ… Enabling Podman auto-update for containers..."
systemctl --user enable --now podman-auto-update.timer
podman auto-update

log "ðŸŽ‰ Arch Fortress Part 2 Installation Complete! ðŸŽ‰"
log "ðŸ“‹ Next steps:"
log "   1. Reboot to load GPU drivers and KDE"
log "   2. Set up Syncthing at http://127.0.0.1:8384"
log "   3. Run 'fortress-status' to check system"
log "   4. Use 'firefox-fortress' for secure browsing"
log "   5. Use 'dev-activate' to enter ML/AI development environment"

info "ðŸ Python Environment Details:"
info "   - System Python: $(python --version 2>/dev/null || echo 'Not available')"
info "   - Development Environment: Python 3.11 with ML/AI packages"
info "   - Activation: 'dev-activate' or 'source ~/.local/share/dev-env/bin/activate'"

info "ðŸ›¡ï¸ Security Features:"
info "   - AppArmor profiles for Firefox, Obsidian and Syncthing"
info "   - MAC address randomization"
info "   - Container isolation with custom networks"
info "   - Snapshot system with automatic cleanup"
info "   - Real-time security monitoring with fail2ban"

info "ðŸš€ Performance Optimizations:"
info "   - NVIDIA GPU acceleration enabled"
info "   - Minimal KDE desktop environment"
info "   - Optimized container resource limits"

warning "âš ï¸  IMPORTANT SECURITY NOTES:"
warning "   - Review and customize AppArmor profiles as needed"
warning "   - Set up firewall rules for your specific use case"
warning "   - Consider enabling full disk encryption if not already done"

log "ðŸ”§ Post-installation hardening recommendations:"
log "   - Run 'sudo rkhunter --check' for rootkit detection"
log "   - Configure automatic security updates"
log "   - Set up encrypted backup strategy"
log "   - Review systemd services and disable unnecessary ones"

# Create post-installation hardening script

tee $HOME/.local/bin/fortress-harden > /dev/null << 'EOF'
#!/bin/bash

# ðŸ”± FORTRESS POST-INSTALLATION HARDENING ðŸ”±

set -euo pipefail

GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[1;33m"
NC="\033[0m"

log() { echo -e "${GREEN}[HARDEN]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

log "ðŸ”’ Running additional security hardeningâ€¦"

# Disable unnecessary systemd services

log "Disabling unnecessary servicesâ€¦"
sudo systemctl disable --now bluetooth.service 2>/dev/null || true
sudo systemctl disable --now cups.service 2>/dev/null || true
sudo systemctl mask systemd-rfkill.service systemd-rfkill.socket 2>/dev/null || true

# Enable process accounting

log "Enabling process accountingâ€¦"
sudo systemctl enable --now psacct 2>/dev/null || true

# Create emergency recovery script

log "Creating emergency recovery toolsâ€¦"
sudo tee /usr/local/bin/fortress-emergency > /dev/null << 'EOEMERG'
#!/bin/bash

# ðŸš¨ FORTRESS EMERGENCY RECOVERY ðŸš¨

RED="\033[0;31m"
GREEN="\033[0;32m"
NC="\033[0m"

echo -e "${RED}ðŸš¨ FORTRESS EMERGENCY MODE ðŸš¨${NC}"
echo "Available recovery options:"
echo "1. Disable all AppArmor profiles"
echo "2. Stop all containers"
echo "3. Reset DNS to system default"
echo "4. List recent snapshots"
echo "5. Boot to snapshot"

read -p "Select option (1-5): " choice

case $choice in
1)
    echo -e "${GREEN}Disabling AppArmor profiles (setting to complain mode)...${NC}"
    sudo aa-complain /etc/apparmor.d/*
    log "AppArmor profiles set to complain mode. Reboot to take full effect."
    ;;
2)
    echo -e "${GREEN}Stopping all containers...${NC}"
    podman stop --all
    podman system prune -f --volumes
    ;;
3)
    echo -e "${GREEN}Resetting DNS to a public resolver (1.1.1.1)...${NC}"
    sudo systemctl stop systemd-resolved
    echo "nameserver 1.1.1.1" | sudo tee /etc/resolv.conf
    sudo systemctl start systemd-resolved
    log "DNS has been reset."
    ;;
4)
    echo -e "${GREEN}Recent snapshots:${NC}"
    sudo snapper -c root list | tail -10
    ;;
5)
    echo -e "${RED}This is a destructive operation.${NC}"
    warning "This will roll back your ENTIRE root filesystem."
    read -p "Enter snapshot number to restore: " snap_num
    if [[ ! "$snap_num" =~ ^[0-9]+$ ]]; then error "Invalid number."; fi

    warning "Restoring snapshot $snap_num. The system will reboot."
    sudo snapper -c root rollback "$snap_num" && sudo reboot
    ;;
*)
    error "Invalid option"
    ;;
esac
EOEMERG

sudo chmod +x /usr/local/bin/fortress-emergency

# Set up intrusion detection alerts

log "Configuring intrusion detectionâ€¦"
sudo tee /etc/fail2ban/action.d/fortress-alert.conf > /dev/null << 'EOALERT'
[Definition]
actionstart = echo "Fortress: fail2ban started on `hostname` at `date`" | logger -t fail2ban
actionstop = echo "Fortress: fail2ban stopped on `hostname` at `date`" | logger -t fail2ban
actioncheck =
actionban = echo "Fortress: banned <ip> from `hostname` at `date`" | logger -t fail2ban
actionunban = echo "Fortress: unbanned <ip> from `hostname` at `date`" | logger -t fail2ban

[Init]
init = 123
EOALERT

# Update fail2ban config to use alerts

sudo sed -i 's/action = %(action_)s/action = %(action_)s\n         fortress-alert/' /etc/fail2ban/jail.local
sudo systemctl restart fail2ban

log "âœ… Additional hardening complete!"
warning "Run 'fortress-emergency' if you encounter critical issues"
EOF

chmod +x $HOME/.local/bin/fortress-harden

# Create system integrity checker

tee $HOME/.local/bin/fortress-check > /dev/null << 'EOF'
#!/bin/bash

# ðŸ”± FORTRESS INTEGRITY CHECKER ðŸ”±

set -euo pipefail

GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
NC="\033[0m"

log() { echo -e "${GREEN}[CHECK]${NC} $1"; }
error() { echo -e "${RED}[FAIL]${NC} $1"; }
warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
info() { echo -e "${BLUE}[INFO]${NC} $1"; }

ERRORS=0

check_service() {
if systemctl --user is-active --quiet "$1" 2>/dev/null; then
log "$1 is running"
else
error "$1 is not running"
((ERRORS++))
fi
}

check_system_service() {
if sudo systemctl is-active --quiet "$1" 2>/dev/null; then
log "$1 is running"
else
error "$1 is not running"
((ERRORS++))
fi
}

echo "ðŸ”± FORTRESS INTEGRITY CHECK ðŸ”±"
echo "================================"

log "Checking core servicesâ€¦"
check_system_service apparmor
check_system_service fail2ban
check_system_service systemd-resolved

log "Checking user servicesâ€¦"
check_service syncthing.service

log "Checking AppArmor profilesâ€¦"
PROFILES=$(sudo apparmor_status | grep -c "profiles are loaded" || echo "0")
if [[ $PROFILES -gt 0 ]]; then
log "$PROFILES AppArmor profiles loaded"
else
error "No AppArmor profiles loaded"
((ERRORS++))
fi

log "Checking DNS resolutionâ€¦"
if nslookup google.com 127.0.0.1 >/dev/null 2>&1; then
log "DNS resolution working"
else
error "DNS resolution failed"
((ERRORS++))
fi

log "Checking development environmentâ€¦"
if [[ -f "$HOME/.local/share/dev-env/bin/python" ]]; then
log "Development environment exists"
PYTHON_VERSION=$($HOME/.local/share/dev-env/bin/python --version)
info "Python: $PYTHON_VERSION"
else
warning "Development environment not found"
fi

log "Checking security toolsâ€¦"
if command -v rkhunter >/dev/null; then
log "Rootkit hunter available"
else
warning "Rootkit hunter not installed"
fi

echo "================================"
if [[ $ERRORS -eq 0 ]]; then
log "ðŸŽ‰ All checks passed! Fortress is secure."
else
error "âŒ $ERRORS issues found. Run 'fortress-harden' to fix."
fi

echo
info "ðŸ’¡ Pro Tips:"
info "   â€¢ Run this check weekly: 'fortress-check'"
info "   â€¢ Monitor logs: 'journalctl -f'"
info "   â€¢ Check snapshots: 'sudo snapper -c root list'"
info "   â€¢ Update containers: 'podman auto-update'"
EOF

chmod +x $HOME/.local/bin/fortress-check

# Final system verification

log "Running system verificationâ€¦"

# Check all created files exist

CRITICAL_FILES=(
"$HOME/.local/bin/fortress-status"
"$HOME/.local/bin/fortress-check"
"$HOME/.local/bin/fortress-harden"
"$HOME/.local/bin/firefox-fortress"
"$HOME/.local/bin/dev-activate"
)

for file in "${CRITICAL_FILES[@]}"; do
if [[ -f "$file" && -x "$file" ]]; then
log "âœ“ $file exists and is executable"
else
error "âœ— $file missing or not executable"
fi
done

# Verify AppArmor profiles

APPARMOR_PROFILES=(
"/etc/apparmor.d/firefox-fortress"
"/etc/apparmor.d/obsidian"
"/etc/apparmor.d/syncthing"
)

for profile in "${APPARMOR_PROFILES[@]}"; do
if [[ -f "$profile" ]]; then
log "âœ“ AppArmor profile $profile installed"
else
error "âœ— AppArmor profile $profile missing"
fi
done

# Update shell configuration for immediate use

source $HOME/.bashrc 2>/dev/null || true

log "ðŸŽ¯ FORTRESS DEPLOYMENT COMPLETE! ðŸŽ¯"
echo
log "ðŸš€ IMMEDIATE NEXT STEPS:"
log "   1. REBOOT NOW: 'sudo reboot'"
log "   2. After reboot, run: 'fortress-check'"
log "   3. Configure DNS: http://127.0.0.1:5380 (user: admin, pass: admin)"
log "   4. Configure sync: http://127.0.0.1:8384"
log "   5. Run hardening: 'fortress-harden'"

echo
warning "ðŸ” SECURITY CHECKLIST:"
warning "   â–¡ Configure firewall rules for your network"
warning "   â–¡ Set up encrypted backups"
warning "   â–¡ Test emergency recovery: 'fortress-emergency'"
warning "   â–¡ Schedule regular security audits"

echo
info "ðŸ› ï¸ DAILY COMMANDS:"
info "   fortress-status  - System overview"
info "   fortress-check   - Integrity verification"  
info "   firefox-fortress - Secure browser"
info "   dev-activate     - ML/AI environment"

echo
log "ðŸŽ‰ Welcome to your impenetrable Arch Fortress! ðŸŽ‰"
log "    You now have enterprise-grade security on a desktop system."
log "    Stay vigilant. Stay secure. ðŸ”±"

# Create a completion marker

touch $HOME/.fortress-part2-complete
echo "$(date)" > $HOME/.fortress-part2-complete

}

# Execute main function

main "$@"
